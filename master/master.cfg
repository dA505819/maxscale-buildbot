# -*- python -*-
# ex: set filetype=python:

from buildbot.interfaces import IRenderable
from buildbot.plugins import *
from buildbot.process.buildstep import ShellMixin
from buildbot.process.buildstep import BuildStep
from buildbot.steps import shell
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.trigger import Trigger
from maxscale.config import constants
from maxscale.config import mailer_config
import datetime
import os
from os import listdir
from os.path import isfile, join, basename
from maxscale.builders import MAXSCALE_BUILDERS
from maxscale.schedulers import MAXSCALE_SCHEDULERS
from maxscale.services import MAXSCALE_SERVICES
import time
from twisted.internet import defer
from zope.interface import implementer


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}


class RunTestSetPropertiesStep(ShellMixin, BuildStep):
    name = 'Set properties'

    def __init__(self, **kwargs):
        kwargs = self.setupShellMixin(kwargs, prohibitArgs=['command'])
        BuildStep.__init__(self, **kwargs)

    @defer.inlineCallbacks
    def run(self):
        # BUILD_TIMESTAMP property
        cmd = yield self.makeRemoteShellCommand(
                            command=['date', "+%Y-%m-%d %H-%M-%S"],
                            collectStdout=True)
        yield self.runCommand(cmd)
        self.setProperty('BUILD_TIMESTAMP', cmd.stdout[0:-1], 'setProperties')
        # SHELL_SCRIPTS_PATH property
        cmd = yield self.makeRemoteShellCommand(
                            command='echo "`pwd`/{}"'.format(constants.WORKER_SHELL_SCRIPTS_RELATIVE_PATH),
                            collectStdout=True)
        yield self.runCommand(cmd)
        self.setProperty('SHELL_SCRIPTS_PATH', cmd.stdout[0:-1], 'setProperties')
        # WORKSPACE property
        cmd = yield self.makeRemoteShellCommand(
                            command='echo "`pwd`/{}"'.format(constants.WORKER_WORKSPACE_RELATIVE_PATH),
                            collectStdout=True)
        yield self.runCommand(cmd)
        self.setProperty('WORKSPACE', cmd.stdout[0:-1], 'setProperties')
        # JOB_NAME property
        self.setProperty('JOB_NAME', 'run_test', 'setProperties')
        # custom_builder_id property
        self.setProperty('custom_builder_id', '101', 'setProperties')
        # BUILD_ID property
        self.setProperty('BUILD_ID', "{}{}".format(self.getProperty('custom_builder_id'),
                                                   self.getProperty('buildnumber')), 'setProperties')
        defer.returnValue(0)


def save_env_to_property(rc, stdout, stderr):
    ''' Function used as the extrat_fn function for SetProperty class
        This takes the output from env command and creates a dictionary of
        the environment, the result of which is stored in a property names
        env'''
    if not rc:
        env_list = [l.strip() for l in stdout.split('\n')]
        env_dict = {l.split('=', 1)[0]: l.split('=', 1)[1] for l in
                    env_list if len(l.split('=', 1)) == 2}
        return {'env': env_dict}


@util.renderer
def get_custom_buildnumber(props):
    command = ['echo']
    command.extend([util.Interpolate('%(prop:custom_builder_id)s%(prop:buildnumber)s')])
    return command


@util.renderer
def create_workspace_command(props):
    command = 'mkdir -p ' + str(props.getProperty('WORKSPACE'))
    return command


@util.renderer
def clean_workspace_command(props):
    command = 'rm -rf ' + str(props.getProperty('WORKSPACE') + "/*")
    return command


shell_scripts_files = [join(os.getcwd(), "shell_scripts", f)
                       for f in listdir(join(os.getcwd(), "shell_scripts"))
                       if isfile(join(os.getcwd(), "shell_scripts", f))]


def download_shell_scripts(step_factory, files):
    for file in files:
        step_factory.addStep(steps.FileDownload(
            mastersrc=file,
            workerdest=util.Interpolate('%(prop:SHELL_SCRIPTS_PATH)s/{}'.format(basename(file))),
            mode=0o755))


# WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [worker.Worker("worker1", "0000")]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

# CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

# c['change_source'] = []

# SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

c['schedulers'] = []

c['schedulers'].extend(MAXSCALE_SCHEDULERS)

# *******************
# BUILD AND TEST
# *******************
c['schedulers'].append(schedulers.ForceScheduler(
    name="build_and_test",
    label="Build and test",
    builderNames=["build_and_test"],
    codebases=[
        util.CodebaseParameter(
            "",
            label="Main repository",
            branch=util.StringParameter(name="branch", default="develop"),
            revision=util.FixedParameter(name="revision", default=""),
            project=util.FixedParameter(name="project", default=""),
            repository=util.StringParameter(name="repository",
                                            default=constants.MAXSCALE_REPOSITORY),
        ),
    ],
    properties=[
        util.StringParameter(name="name", label="Name of this build", size=50, default="test01"),  # +
        util.StringParameter(name="target", label="Target", size=50, default="develop"),  # +
        util.ChoiceStringParameter(
            name="build_experimental",
            label="Build experimental",
            choices=["yes", "no"],
            default="yes"),
        util.ChoiceStringParameter(
            name="box",
            label="Box",
            choices=constants.BOXES,
            default=constants.BOXES[0]),  # +
        util.ChoiceStringParameter(
            name="product",
            label="Product",
            choices=['mariadb', 'mysql'],
            default='mariadb'),  # +
        util.ChoiceStringParameter(
            name="version",
            label="Version",
            choices=constants.DB_VERSIONS,
            default=constants.DB_VERSIONS[0]),  # +
        util.StringParameter(name="cmake_flags", label="CMake flags", size=50,
                             default=constants.DEFAULT_CMAKE_FLAGS),
        util.ChoiceStringParameter(
            name="do_not_destroy_vm",
            label="Do not destroy vm",
            choices=['no', 'yes'],
            default='no'),  # +
        util.StringParameter(name="test_set", label="Test set", size=50, default="-LE HEAVY"),  # +
        util.StringParameter(name="ci_url", label="ci url", size=50,
                             default=constants.CI_SERVER_URL),  # +
        util.ChoiceStringParameter(
            name="smoke",
            label="Run fast versions of every test",
            choices=["yes", "no"],
            default="yes"),  # +
        util.ChoiceStringParameter(
            name="big",
            label="Use larger number of VMs",
            choices=["yes", "no"],
            default="yes"),  # +
        util.ChoiceStringParameter(
            name="backend_ssl",
            label="Backend ssl",
            choices=["no", "yes"],
            default="no"),  # +
    ]))

# *******************
# CLEANUP
# *******************
c['schedulers'].append(schedulers.Triggerable(
    name="cleanup",
    builderNames=["cleanup"],
))

c['schedulers'].append(schedulers.ForceScheduler(
    name="cleanup_force",
    builderNames=["cleanup"],
    codebases=[
        util.CodebaseParameter(
            "",
            branch=util.FixedParameter(name="branch", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            project=util.FixedParameter(name="project", default=""),
            repository=util.FixedParameter(name="repository",
                                           default=""),
        ),
    ],
    properties=[
        util.StringParameter(name="name", label="Name of this build", size=50, default="test01"),
        util.ChoiceStringParameter(
            name="do_not_destroy_vm",
            label="Do not destroy vm",
            choices=['no', 'yes'],
            default='no'),
        util.StringParameter(name="build_full_name", label="Build full name ('JOB_NAME-BUILD_ID')", size=50),
        util.ChoiceStringParameter(
            name="try_already_running",
            label="Try already running",
            choices=["no", "yes"],
            default="no"),
        util.ChoiceStringParameter(
            name="box",
            label="Box",
            choices=constants.BOXES,
            default=constants.BOXES[0]),
    ]
))

# *******************
# DESTROY
# *******************
c['schedulers'].append(schedulers.Triggerable(
    name="destroy",
    builderNames=["destroy"],
))

c['schedulers'].append(schedulers.ForceScheduler(
    name="destroy_force",
    builderNames=["destroy"],
    codebases=[
        util.CodebaseParameter(
            "",
            branch=util.FixedParameter(name="branch", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            project=util.FixedParameter(name="project", default=""),
            repository=util.FixedParameter(name="repository",
                                           default=""),
        ),
    ],
    properties=[
        util.StringParameter(name="name", label="Name of this build", size=50, default="test01"),
        util.ChoiceStringParameter(
            name="do_not_destroy_vm",
            label="Do not destroy vm",
            choices=['no', 'yes'],
            default='no'),
        util.ChoiceStringParameter(
            name="try_already_running",
            label="Try already running",
            choices=["no", "yes"],
            default="no"),
    ]
))

# *******************
# SMART REMOVE LOCK
# *******************
c['schedulers'].append(schedulers.Triggerable(
    name="smart_remove_lock",
    builderNames=["smart_remove_lock"],
))

c['schedulers'].append(schedulers.ForceScheduler(
    name="smart_remove_lock_force",
    builderNames=["smart_remove_lock"],
    codebases=[
        util.CodebaseParameter(
            "",
            branch=util.FixedParameter(name="branch", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            project=util.FixedParameter(name="project", default=""),
            repository=util.FixedParameter(name="repository",
                                           default=""),
        ),
    ],
    properties=[
        util.StringParameter(name="build_full_name", label="Build full name ('JOB_NAME-BUILD_ID')", size=50),
        util.ChoiceStringParameter(
            name="try_already_running",
            label="Try already running",
            choices=["no", "yes"],
            default="no"),
        util.ChoiceStringParameter(
            name="box",
            label="Box",
            choices=constants.BOXES,
            default=constants.BOXES[0]),
    ]
))

# *******************
# REMOVE LOCK
# *******************
c['schedulers'].append(schedulers.Triggerable(
    name="remove_lock",
    builderNames=["remove_lock"],
))

c['schedulers'].append(schedulers.ForceScheduler(
    name="remove_lock_force",
    builderNames=["remove_lock"],
    codebases=[
        util.CodebaseParameter(
            "",
            branch=util.FixedParameter(name="branch", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            project=util.FixedParameter(name="project", default=""),
            repository=util.FixedParameter(name="repository",
                                           default=""),
        ),
    ],
    properties=[
        util.ChoiceStringParameter(
            name="try_already_running",
            label="Try already running",
            choices=["no", "yes"],
            default="no"),
        util.ChoiceStringParameter(
            name="box",
            label="Box",
            choices=constants.BOXES,
            default=constants.BOXES[0]),
    ]
))

# *******************
# DOWNLOAD SHEL SCRIPTS
# *******************
c['schedulers'].append(schedulers.Triggerable(
    name="download_shell_scripts",
    builderNames=["download_shell_scripts"]
))

# BUILDERS

factory_build_and_test = util.BuildFactory()
factory_run_test = util.BuildFactory()


factory_download_shell_scripts = util.BuildFactory()
factory_cleanup = util.BuildFactory()
factory_destroy = util.BuildFactory()
factory_smart_remove_lock = util.BuildFactory()
factory_remove_lock = util.BuildFactory()

# *******************
# DOWNLOAD SHELL SCRIPTS BUILDER
# *******************

download_shell_scripts(factory_download_shell_scripts, shell_scripts_files)

# *******************
# DESTROY BUILDER
# *******************

factory_destroy.addStep(steps.SetPropertyFromCommand(
    name="Set the 'SHELL_SCRIPTS_PATH' property",
    command='echo "`pwd`/../shell_scripts"',
    property="SHELL_SCRIPTS_PATH",
    haltOnFailure=True, ))
factory_destroy.addStep(Trigger(
    name="Call the 'download_shell_scripts' scheduler",
    schedulerNames=['download_shell_scripts'],
    waitForFinish=True,
    haltOnFailure=True,
    copy_properties=['SHELL_SCRIPTS_PATH']
))
factory_destroy.addStep(shell.SetProperty(
    name="Set the 'env' property",
    command="bash -c env",
    haltOnFailure=True,
    extract_fn=save_env_to_property,
    env={
        "name": util.Property('name'),
        "do_not_destroy_vm": util.Property('do_not_destroy_vm'),
        "try_already_running": util.Property('try_already_running'),
    }))
factory_destroy.addStep(steps.ShellCommand(
    name="Run the 'run_destroy_wrapper.sh' script",
    command=['sh', util.Interpolate('%(prop:SHELL_SCRIPTS_PATH)s/run_destroy_wrapper.sh')],
    haltOnFailure=True,
    env=util.Property('env')))

# *******************
# REMOVE LOCK BUILDER
# *******************


factory_remove_lock.addStep(steps.SetPropertyFromCommand(
    name="Set the 'SHELL_SCRIPTS_PATH' property",
    command='echo "`pwd`/../shell_scripts"',
    property="SHELL_SCRIPTS_PATH",
    haltOnFailure=True, ))
factory_remove_lock.addStep(Trigger(
    name="Call the 'download_shell_scripts' scheduler",
    schedulerNames=['download_shell_scripts'],
    waitForFinish=True,
    haltOnFailure=True,
    copy_properties=['SHELL_SCRIPTS_PATH']
))
factory_remove_lock.addStep(shell.SetProperty(
    name="Set the 'env' property",
    command="bash -c env",
    haltOnFailure=True,
    extract_fn=save_env_to_property,
    env={
        "try_already_running": util.Property('try_already_running'),
        "box": util.Property('box'),
    }))
factory_remove_lock.addStep(steps.ShellCommand(
    name="Run the 'run_remove_lock.sh' script",
    command=['sh', util.Interpolate('%(prop:SHELL_SCRIPTS_PATH)s/run_remove_lock.sh')],
    haltOnFailure=True,
    env=util.Property('env')))

# *************************
# SMART REMOVE LOCK BUILDER
# *************************

factory_smart_remove_lock.addStep(steps.SetPropertyFromCommand(
    name="Set the 'SHELL_SCRIPTS_PATH' property",
    command='echo "`pwd`/../shell_scripts"',
    property="SHELL_SCRIPTS_PATH",
    haltOnFailure=True, ))
factory_smart_remove_lock.addStep(Trigger(
    name="Call the 'download_shell_scripts' scheduler",
    schedulerNames=['download_shell_scripts'],
    waitForFinish=True,
    haltOnFailure=True,
    copy_properties=['SHELL_SCRIPTS_PATH']
))
factory_smart_remove_lock.addStep(shell.SetProperty(
    name="Set the 'env' property",
    command="bash -c env",
    haltOnFailure=True,
    extract_fn=save_env_to_property,
    env={
        "build_full_name": util.Property('build_full_name'),
        "try_already_running": util.Property('try_already_running'),
        "box": util.Property('box'),
    }))
factory_smart_remove_lock.addStep(steps.ShellCommand(
    name="Run the 'run_smart_remove_lock_wrapper.sh' script",
    command=['sh', util.Interpolate('%(prop:SHELL_SCRIPTS_PATH)s/run_smart_remove_lock_wrapper.sh')],
    haltOnFailure=True,
    env=util.Property('env')))
factory_smart_remove_lock.addStep(Trigger(
    name="Call the 'remove_lock' scheduler",
    schedulerNames=['remove_lock'], waitForFinish=True,
    alwaysRun=True,
    copy_properties=[
        "try_already_running",
        "box",
    ]))

# *******************
# CLEANUP BUILDER
# *******************

factory_cleanup.addStep(shell.SetProperty(
    name="Set the 'env' property",
    command="bash -c env",
    haltOnFailure=True,
    extract_fn=save_env_to_property,
    env={
        "name": util.Property('name'),
        "do_not_destroy_vm": util.Property('do_not_destroy_vm'),
        "build_full_name": util.Property('build_full_name'),
        "try_already_running": util.Property('try_already_running'),
        "box": util.Property('box'),
    }))
factory_cleanup.addStep(Trigger(
    name="Call the 'destroy' scheduler",
    schedulerNames=['destroy'],
    waitForFinish=True,
    copy_properties=[
        "name",
        "do_not_destroy_vm",
        "try_already_running",
    ]))
factory_cleanup.addStep(Trigger(
    name="Call the 'smart_remove_lock' scheduler",
    schedulerNames=['smart_remove_lock'],
    waitForFinish=True,
    copy_properties=[
        "build_full_name",
        "try_already_running",
        "box",
    ]))

# *********************
# BUILD AND TEST BUILDER
# *********************
factory_build_and_test.addStep(Trigger(
    name="Call the 'build' scheduler",
    schedulerNames=['build'],
    waitForFinish=True,
    haltOnFailure=True,
    copy_properties=[
        "name",
        "repository",
        "branch",
        "target",
        "build_experimental",
        "box",
        "product",
        "version",
        "cmake_flags"
        "do_not_destroy_vm",
        "test_set",
        "ci_url",
        "smoke",
        "big"]
))

factory_build_and_test.addStep(Trigger(
    name="Call the 'run_test' scheduler",
    schedulerNames=['run_test'],
    waitForFinish=True,
    copy_properties=[
        "name",
        "repository",
        "branch",
        "target",
        "build_experimental",
        "box",
        "product",
        "version",
        "cmake_flags"
        "do_not_destroy_vm",
        "test_set",
        "ci_url",
        "smoke",
        "big"],
    set_properties={'test_branch': util.Property('branch')}
))

# BUILDERS

c['builders'] = []
c['builders'].extend(MAXSCALE_BUILDERS)
c['builders'].append(util.BuilderConfig(
    name="build_and_test",
    workernames=["worker1"],
    factory=factory_build_and_test,
    tags=['build', 'test'],
    env=dict(os.environ)))
c['builders'].append(util.BuilderConfig(
    name="cleanup",
    workernames=["worker1"],
    factory=factory_cleanup,
    tags=['cleanup'],
    env=dict(os.environ)))
c['builders'].append(util.BuilderConfig(
    name="destroy",
    workernames=["worker1"],
    factory=factory_destroy,
    tags=['axilary'],
    env=dict(os.environ)))
c['builders'].append(util.BuilderConfig(
    name="smart_remove_lock",
    workernames=["worker1"],
    factory=factory_smart_remove_lock,
    tags=['axilary'],
    env=dict(os.environ)))
c['builders'].append(util.BuilderConfig(
    name="remove_lock",
    workernames=["worker1"],
    factory=factory_remove_lock,
    tags=['axilary'],
    env=dict(os.environ)))
c['builders'].append(util.BuilderConfig(
    name="download_shell_scripts",
    workernames=["worker1"],
    factory=factory_download_shell_scripts,
    env=dict(os.environ)))

# BUILDBOT SERVICES

c['services'] = MAXSCALE_SERVICES

# PROJECT IDENTITY

c['title'] = "MaxScale CI"
c['titleURL'] = "https://github.com/mariadb-corporation/maxscale-buildbot"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://localhost:8010/"

# minimalistic config to activate new web UI
c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}, grid_view={}))

# DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url': "sqlite:///state.sqlite",
}
